package jrJava.typeAdvanced;

public class Test {

	public static void main(String[] args) {
//
//		
//		//up-casting: follow the arrows. always true, automatic
//		E ref1 = null;
//		B ref2 = ref1; 
//		A ref3 = ref1;
//		I ref4 = ref1; //they can access 9 methods of cosmic super class and mI();				
//		Object ref5 = ref1;
//		
//		//downcasting : follow the opposite direction of the arrows.
//		//It's all basedon 'possibility'
//		A ref1 = new A();
//		//B ref2 = (B)ref1; //compile time OK, runtime not OK
//		
//		A ref3 = new E();
//		B ref4 = (B) ref3; //compile time OK, runtime OK
//		
//		A ref5 = null;
//		B ref6 = (B)ref5;
//		
//		//side-ways:
//		C ref1 = null;
//		B ref2 = (B)ref1; //impossible. compile time not OK
//		
//		A ref1 = null;
//		A ref2 = ref1;
//		B ref3 = (B)ref2; //compile time OK, runtime not OK
//		
//		C ref1 = null;
//		A ref2 = ref1;
//		B ref3 = (B)ref2; //Compile time OK, runtime OK (because it is null)
//		
//		//conversion class to interface
//		A ref1 = new E();
//		I ref2 = (I)ref1;
//		
//		C ref1 = new C();
//		I ref2 = (I)ref1; //Any object can be any interface type. Possible. But runtime not OK
//		
//		I ref1 = new B();
//		A ref =2 (A)ref1;
		
		
		
	}

}
